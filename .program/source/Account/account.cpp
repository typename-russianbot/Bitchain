#include "../../includes/Account/account.h"

//? @defgroup: Helpers
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//^ @protected: lookup
//^ @def: searches & stores target account data if found in savefile

bool Account::lookup(const string target)
{
    //& @note: file validation & parsing
    ifstream savefile(".resources/Accounts/accounts.txt");
    if (!FileValidation(savefile))
    {
        cerr << "<error>=savefile_loading" << endl;
        return false;
    }

    string line;
    while (getline(savefile, line))
    {
        stringstream currentline(line);
        string nUsername;

        //* @note: lookup hit
        if (getline(currentline, nUsername, ',') && nUsername == target)
        {
            string nPasskey, nKeys;
            getline(currentline, nPasskey, ',');
            getline(currentline, nKeys);

            username = nUsername;
            passkey = nPasskey;
            keys = atoi(nKeys.c_str());

            return true;
        }
    }

    //! @note: lookup missed
    return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//^ @protected: probe
bool Account::probe(void)
{
    //& @note: file validation
    ifstream cachefile(".resources/Accounts/cache.txt");
    if (!FileValidation(cachefile))
    {
        cerr << "<error>=cache_loading" << endl;
        return false;
    }

    //&  @note: attempt to load from cache
    string line;
    getline(cachefile, line);
    stringstream currentline(line);

    //* @note: probe success
    string nUsername, nPasskey, nKeys;
    if (getline(currentline, nUsername, ',') && getline(currentline, nPasskey, ',') && getline(currentline, nKeys))
    {
        username = nUsername;
        passkey = nPasskey;
        keys = atoi(nKeys.c_str());
        return true;
    }

    //! @note: probe failed
    return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//? @defgroup: Resources
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: Account(const string, const string)
Account::Account(const string newUsername, const string newPasskey) : username(newUsername), passkey(newPasskey), keys(0), bitchain() { return; }
//* @public: Account(const Account&)
Account::Account(const Account &account) : username(account.username), passkey(account.passkey), keys(account.keys), bitchain(account.bitchain) { return; }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: ~Account(void)
Account::~Account(void) { return; }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//? @defgroup: Functions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: add(void)
void Account::add(void)
{
    //& @note: grab keyname, username, email, & password
    string keyname, username, email, password;
    do
    {
        cout << "Keyname: ";
        getline(cin, keyname);

        if (keyname.empty())
        {
            keyname = "none";
            break;
        }
    } while (!InputValidation(keyname));
    do
    {
        cout << "Username: ";
        getline(cin, username);

        if (username.empty())
        {
            username = "none";
            break;
        }
    } while (!InputValidation(username));
    do
    {
        cout << "Email: ";
        getline(cin, email);

        if (email.empty())
        {
            email = "none";
            break;
        }
    } while (!InputValidation(email));
    do
    {
        cout << "Password: ";
        HideTerminal();
        getline(cin, password);
        ShowTerminal();

        if (password.empty())
        {
            password = "password";
            break;
        }
    } while (!InputVerification(password));

    //& @note: add key to bitchain
    Key key(keyname, {username, password, email});
    if (bitchain.add(key))
    {
        keys++;
        cout << "Added '" << keyname << "' key" << endl;
    }
    else
        cerr << "<error>=operation_terminated" << endl;

    return;
}

//* @public: add(const Key&)
void Account::add(const Key &key)
{
    //& @note: add key to bitchain
    bitchain.add(key);
    keys++;
    cout << "Added Key" << endl;

    return;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: remove(void)
void Account::remove(void)
{
    //& @note: grab target & begin search
    string target;
    do
    {
        cout << "Target: ";
        getline(cin, target);

        //! @note: target not given
        if (target.empty())
        {
            cout << "Target not specified" << endl;
            return;
        }
    } while (!InputValidation(target));

    //* @note: target hit
    if (bitchain.search(target))
    {
        cout << "Remove Key | ";
        if (ConfirmOperation())
        {
            bitchain.remove(target);
            keys--;
            cout << "Removed '" << target << "' key" << endl;
        }
        else
            cerr << "<error>=operation_terminated" << endl;
    }

    //! @note: target miss
    else
        cerr << "<error>=search_miss" << endl;

    return;
}

//* @public: remove(const string)
void Account::remove(const string target)
{
    //& @note: begin search
    if (bitchain.search(target)) //* @note: target hit
    {
        cout << "Remove Key | ";
        if (ConfirmOperation())
        {
            bitchain.remove(target);
            keys--;
            cout << "Removed '" << target << "' key" << endl;
        }
        else
            cerr << "<error>=operation_terminated" << endl;
    }
    else //! @note: target missed
        cerr << "<error>=search_miss" << endl;

    return;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: search(void)
void Account::search(void)
{
    //& @note: grab search target
    string target;
    do
    {
        cout << "Target: ";
        cin >> target;
    } while (!InputValidation(target));

    //& @note: proceed w/ target search
    if (bitchain.search(target))
        cout << "Target Found: " << target << endl; //* @note: search hit
    else
        cerr << "<error>=target_miss" << endl; //! @note: search miss

    return;
}

//* @public: search(const string)
void Account::search(const string target)
{
    //& @note: begin target search
    if (bitchain.search(target)) //* @note: target hit
        cout << "Target Found: " << target << endl;
    else
        cerr << "<error>=target_miss" << endl;

    return;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: print(void)
void Account::print(void)
{
    cout << bitchain << endl;
    return;
}

//* @public: print(const string)
void Account::print(const string target)
{
    if (!bitchain.show(target))
    {
        cerr << "<error>=function_failure" << endl;
    }

    return;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// todo @public: save(void)
bool Account::save(void)
{
    //& @note: validate resource file
    ofstream outputfile(".resources/Accounts/accounts.txt", ios::app);
    if (!FileValidation(outputfile))
    {
        cerr << "<error> = file failed to open" << endl;
        return false;
    }

    //& @note: attempt account saving
    cout << "Save Bitchain Account | ";
    if (!ConfirmOperation())
    {
        cout << "Operation Terminated" << endl;
        outputfile.close();
        return false;
    }

    //* @note: write Account contents to 'accounts.txt'
    outputfile << username << "," << passkey << "," << keys << endl;

    //* @note: write Bitchain contents to 'username.txt'
    ofstream bitchainfile(".resources/Bitchains/" + username + ".txt");
    if (bitchain.save(bitchainfile))
    {
        // ? @note : close files to avoid leaks
        outputfile.close();
        return true;
    }

    return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: wipe(void)
bool Account::wipe(void)
{

    //? @note: grab & validate inputfile, create new tempfile
    ifstream inputfile(".resources/Accounts/accounts.txt");
    if (!FileValidation(inputfile))
    {
        cerr << "File failed to open" << endl;
        return false;
    }

    //* @note: grab user confirmation
    cout << "Delete Bitchain Account | ";
    if (!ConfirmOperation())
    {
        cerr << "<Operation Terminated>" << endl;
        inputfile.close();
        return false;
    }

    //* @note: delete bitchain savefile
    string WipeBitchain = "rm -rf .resources/Bitchains/" + username + ".txt";
    system(WipeBitchain.c_str());

    ofstream tempfile(".resources/Accounts/temp.txt");

    //* @note: copy all inputfile contents except target
    string line;
    while (getline(inputfile, line))
    {
        if (line.find(username) == string::npos)
            tempfile << line << endl;
    }

    //? @note: close files
    inputfile.close();
    tempfile.close();
    rename(".resources/Accounts/temp.txt", ".resources/Accounts/accounts.txt");

    return true;
}

//* @public: wipe(const string)
bool Account::wipe(const string target)
{
    if (lookup(target))
    {
        wipe();
        return true;
    }

    return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: load(void)
bool Account::load(void)
{
    //& @note: prompt for input & attempt lookup
    string target;
    do
    {
        cout << "Target: ";
        getline(cin, target);

        //! @note: no target was given
        if (target.empty())
        {
            cout << "Target not specified" << endl;
            return false;
        }
    } while (!InputValidation(target));

    //* @note: account hit
    if (lookup(target))
    {
        cout << "Target Found: " << target << endl;
        ifstream bitchainfile(".resources/Bitchains/" + username + ".txt");

        if (bitchain.load(bitchainfile))
            return true;
    }

    //! @note: account miss
    return false;
}

//* @public: load(const string)
bool Account::load(const string target)
{
    //* @note: target hit
    if (lookup(target))
    {
        ifstream bitchainfile(".resources/Bitchains/" + target + ".txt");
        if (bitchain.load(bitchainfile))
            return true;
    }

    return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: saveToCache(void)
bool Account::saveToCache(void)
{
    //? @note: grab & validate cache
    ofstream cachefile(".resources/Accounts/cache.txt");
    if (!FileValidation(cachefile))
    {
        cerr << "<error>==file_opening" << endl;
        return false;
    }

    //? @note: write Account data to cache
    cachefile << username << "," << passkey << "," << keys << endl;
    cachefile.close();
    return true;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: loadFromCache(void)
bool Account::loadFromCache(void)
{
    //* @note: probe successful
    if (probe())
    {
        cout << "Target Loaded from Cache" << endl;
        ifstream bitchainfile(".resources/Bitchains/" + username + ".txt");

        if (bitchain.load(bitchainfile))
            return true;
    }

    //! @note: bitchain failed to load
    return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//? @defgroup: Mutators
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: setUsername(const string)
void Account::setUsername(const string nUsername)
{
    username = nUsername;
    return;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: setPasskey(const string)
void Account::setPasskey(const string nPasskey)
{
    passkey = nPasskey;
    return;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: setKeys(const int)
void Account::setKeys(const int nKeys)
{
    keys = nKeys;
    return;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//? @defgroup: Accessors
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: getUsername(void)
const string Account::getUsername(void) { return username; }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: getPasskey(void)
const string Account::getPasskey(void) { return passkey; }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: getKeys(void)
int Account::getKeys(void) { return keys; }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//? @defgroup: Overloads
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: operator<<(ostream&, const Account&)
ostream &operator<<(ostream &out, const Account &account)
{
    out << "|--------------------------------------------------|" << endl
        << "   Bitchain Account" << endl
        << "\t- Username:\t" << account.username << endl
        << "\t- Passkey:\t" << account.passkey << endl
        << "\t- Keys:\t\t" << account.keys << endl
        << "|--------------------------------------------------|";

    return out;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//* @public: operator=(const Account&)
Account &Account::operator=(const Account &other)
{
    this->username = other.username;
    this->passkey = other.passkey;
    this->keys = other.keys;
    this->bitchain = other.bitchain;

    return *this;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
